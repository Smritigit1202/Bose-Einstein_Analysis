# -*- coding: utf-8 -*-
"""Asm.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zEM_bmTQA1VjlfiE7hvKdkX_ESR6Yoyq
"""

import numpy as np

Emax = 30
States = []

for E_x in range(Emax):
    for E_y in range(Emax):
        for E_z in range(Emax):
            States.append((E_x + E_y + E_z, E_x, E_y, E_z))

States = np.array(States)
States = States[np.argsort(States[:, 0])]

for k in range(Emax):
    print('%3d' % k, States[k, 0], (States[k, 1], States[k, 2], States[k,3]))

import math
import numpy as np
import matplotlib.pyplot as plt

def bosons_bounded_harmonic(beta, N):
    Energy = []
    n_states_1p = 0
    for n in range(N + 1):
        degeneracy = (n + 1) * (n + 2) / 2
        Energy.extend([float(n)] * int(degeneracy))
        n_states_1p += int(degeneracy)

    n_states_5p = 0
    Z = 0.0
    N0_mean = 0.0
    E_mean = 0.0

    from itertools import combinations_with_replacement
    for state in combinations_with_replacement(range(n_states_1p), 5):
        n_states_5p += 1
        E = sum(Energy[s] for s in state)
        exp_term = math.exp(-beta * E)
        Z += exp_term
        E_mean += E * exp_term
        N0_mean += state.count(0) * exp_term

    return n_states_5p, Z, E_mean, N0_mean

N = 4
beta = 1.0

n_states_5p, Z, E_mean, N0_mean = bosons_bounded_harmonic(beta, N)

print('Temperature:', 1 / beta, 'Total number of possible states:', n_states_5p, '| Partition function:', Z, \
      '| Average energy per particle:', E_mean / Z / 5.0, \
      '| Condensate fraction (ground state occupation per particle):', N0_mean / Z / 5.0)


cond_frac = []
temperature = []
for T in np.linspace(0.1, 1.0, 10):
    n_states_5p, Z, E_mean, N0_mean = bosons_bounded_harmonic(1.0 / T, N)
    cond_frac.append(N0_mean / Z / 5.0)
    temperature.append(T)

plt.plot(temperature, cond_frac)
plt.title(f'Condensate fraction for the N=5 bosons bounded trap model (N_bound={N})', fontsize=14)
plt.xlabel('$T$', fontsize=14)
plt.ylabel('$\\langle N_0 \\rangle$ / N', fontsize=14)
plt.grid()
plt.show()

import random
N = 3
statistics = {}
L = list(range(N))
nsteps = 10
for step in range(nsteps):
    i = random.randint(0, N - 1)
    j = random.randint(0, N - 1)
    L[i], L[j] = L[j], L[i]
    if tuple(L) in statistics:
        statistics[tuple(L)] += 1
    else:
        statistics[tuple(L)] = 1
    print(L)
    print(list(range(N)))
    print()

for item in statistics:
    print(item, statistics[item])

import random

N = 20
stats = [0] * (N + 1)
L = list(range(N))
nsteps = 1000000
for step in range(nsteps):
    i = random.randint(0, N - 1)
    j = random.randint(0, N - 1)
    L[i], L[j] = L[j], L[i]
    if step % 100 == 0:
        cycle_dict = {}
        for k in range(N):
            cycle_dict[k] = L[k]
        while cycle_dict != {}:
            starting_element = list(cycle_dict.keys())[0]
            cycle_length = 0
            old_element = starting_element
            while True:
                cycle_length += 1
                new_element = cycle_dict.pop(old_element)
                if new_element == starting_element: break
                else: old_element = new_element
            stats[cycle_length] += 1
for k in range(1, N + 1):
    print(k, stats[k])

import random, math, pylab
from mpl_toolkits.mplot3d import Axes3D

def levy_harmonic_path(k, beta):
    xk = tuple([random.gauss(0.0, 1.0 / math.sqrt(2.0 *
                math.tanh(k * beta / 2.0))) for d in range(3)])
    x = [xk]
    for j in range(1, k):
        Upsilon_1 = (1.0 / math.tanh(beta) +
                     1.0 / math.tanh((k - j) * beta))
        Upsilon_2 = [x[j - 1][d] / math.sinh(beta) + xk[d] /
                     math.sinh((k - j) * beta) for d in range(3)]
        x_mean = [Upsilon_2[d] / Upsilon_1 for d in range(3)]
        sigma = 1.0 / math.sqrt(Upsilon_1)
        dummy = [random.gauss(x_mean[d], sigma) for d in range(3)]
        x.append(tuple(dummy))
    return x

def rho_harm(x, xp, beta):
    Upsilon_1 = sum((x[d] + xp[d]) ** 2 / 4.0 *
                    math.tanh(beta / 2.0) for d in range(3))
    Upsilon_2 = sum((x[d] - xp[d]) ** 2 / 4.0 /
                    math.tanh(beta / 2.0) for d in range(3))
    return math.exp(- Upsilon_1 - Upsilon_2)

N = 256
T_star = 0.3
beta = 1.0 / (T_star * N ** (1.0 / 3.0))
nsteps = 1000000
positions = {}
for j in range(N):
    a = levy_harmonic_path(1, beta)
    positions[a[0]] = a[0]

for step in range(nsteps):
    boson_a = random.choice(list(positions.keys()))
    perm_cycle = []
    while True:
        perm_cycle.append(boson_a)
        boson_b = positions.pop(boson_a)
        if boson_b == perm_cycle[0]: break
        else: boson_a = boson_b
    k = len(perm_cycle)
    perm_cycle = levy_harmonic_path(k, beta)
    positions[perm_cycle[-1]] = perm_cycle[0]
    for j in range(len(perm_cycle) - 1):
        positions[perm_cycle[j]] = perm_cycle[j + 1]

    a_1 = random.choice(list(positions.keys()))
    b_1 = positions.pop(a_1)
    a_2 = random.choice(list(positions.keys()))
    b_2 = positions.pop(a_2)
    weight_new = rho_harm(a_1, b_2, beta) * rho_harm(a_2, b_1, beta)
    weight_old = rho_harm(a_1, b_1, beta) * rho_harm(a_2, b_2, beta)
    if random.uniform(0.0, 1.0) < weight_new / weight_old:
        positions[a_1] = b_2
        positions[a_2] = b_1
    else:
        positions[a_1] = b_1
        positions[a_2] = b_2

fig = pylab.figure()
ax = fig.add_subplot(111, projection='3d')
ax.set_aspect('auto')  # was 'equal' which may cause warning

list_colors = ['b', 'g', 'r', 'c', 'm', 'y', 'k']
n_colors = len(list_colors)
dict_colors = {}
i_color = 0

while positions:
    x, y, z = [], [], []
    starting_boson = list(positions.keys())[0]
    boson_old = starting_boson
    while True:
        x.append(boson_old[0])
        y.append(boson_old[1])
        z.append(boson_old[2])
        boson_new = positions.pop(boson_old)
        if boson_new == starting_boson: break
        else: boson_old = boson_new
    len_cycle = len(x)
    if len_cycle > 2:
        x.append(x[0])
        y.append(y[0])
        z.append(z[0])
    if len_cycle in dict_colors:
        color = dict_colors[len_cycle]
        ax.plot(x, y, z, color + '+-', lw=0.75)
    else:
        color = list_colors[i_color]
        i_color = (i_color + 1) % n_colors
        dict_colors[len_cycle] = color
        ax.plot(x, y, z, color + '+-', label='k=%i' % len_cycle, lw=0.75)

pylab.title('$N=%i$, $T^*=%s$' % (N, T_star))
pylab.legend()
ax.set_xlabel('$x$', fontsize=16)
ax.set_ylabel('$y$', fontsize=16)
ax.set_zlabel('$z$', fontsize=16)
ax.set_xlim3d([-8, 8])
ax.set_ylim3d([-8, 8])
ax.set_zlim3d([-8, 8])
pylab.show()

import math, pylab

def z(k, beta):
    return 1.0 / (1.0 - math.exp(- k * beta)) ** 3  # partition function of a single particle in a harmonic trap

def canonic_recursion(N, beta):  # Landsberg recursion relations for the partition function of N bosons
    Z = [1.0]  # Z_0 = 1
    for M in range(1, N + 1):
        Z.append(sum(Z[k] * z(M - k, beta) for k in range(M)) / M)
    return Z  # list of partition functions for boson numbers up to N

N = 256  # number of bosons
T_star = 0.5  # temperature
beta = 1.0 / N ** (1.0 / 3.0) / T_star
Z = canonic_recursion(N, beta)  # partition function

pi_k = [(z(k, beta) * Z[N - k] / Z[-1]) / float(N) for k in range(1, N + 1)]  # probability of a cycle of length k

# graphics output
pylab.plot(range(1, N + 1), pi_k, 'b-', lw=2.5)
pylab.ylim(0.0, 0.01)
pylab.xlabel('cycle length $k$', fontsize=16)
pylab.ylabel('cycle probability $\pi_k$', fontsize=16)
pylab.title('Cycle length distribution ($N=%i$, $T^*=%s$)' % (N, T_star), fontsize=16)
pylab.savefig('plot-prob_cycle_length.png')

# This line had an undefined variable `pi` â€“ likely you meant `pi_k`:
phase = [pi_k[k + 1] - pi_k[k] for k in range(1, N - 1)]

# graphics output again
pylab.plot(range(1, N + 1), pi_k, 'b-', lw=2.5)
pylab.ylim(0.0, 0.01)
pylab.xlabel('cycle length $k$', fontsize=16)
pylab.ylabel('cycle probability $\pi_k$', fontsize=16)
pylab.title('Cycle length distribution ($N=%i$, $T^*=%s$)' % (N, T_star), fontsize=16)

pylab.show()

import math, random

def z(k, beta):
    return (1.0 - math.exp(- k * beta)) ** (-3)

def canonic_recursion(N, beta):
    Z = [1.0]
    for M in range(1, N + 1):
        Z.append(sum(Z[k] * z(M - k, beta) for k in range(M)) / M)
    return Z

def make_pi_list(Z, M):
    pi_list = [0.0] + [z(k, beta) * Z[M - k] / Z[M] / M for k in range(1, M + 1)]
    pi_cumulative = [0.0]
    for k in range(1, M + 1):
        pi_cumulative.append(pi_cumulative[k - 1] + pi_list[k])
    return pi_cumulative

def naive_tower_sample(pi_cumulative):
    eta = random.uniform(0.0, 1.0)
    for k in range(len(pi_cumulative)):
        if eta < pi_cumulative[k]:
            break
    return k

def levy_harmonic_path(dtau, N):
    beta = N * dtau
    x_N = random.gauss(0.0, 1.0 / math.sqrt(2.0 * math.tanh(beta / 2.0)))
    x = [x_N]
    for k in range(1, N):
        dtau_prime = (N - k) * dtau
        Upsilon_1 = 1.0 / math.tanh(dtau) + 1.0 / math.tanh(dtau_prime)
        Upsilon_2 = x[k - 1] / math.sinh(dtau) + x_N / math.sinh(dtau_prime)
        x_mean = Upsilon_2 / Upsilon_1
        sigma = 1.0 / math.sqrt(Upsilon_1)
        x.append(random.gauss(x_mean, sigma))
    return x

N = 8
T_star = 0.1
beta = 1.0 / N ** (1.0 / 3.0) / T_star
n_steps = 1000
Z = canonic_recursion(N, beta)

for step in range(n_steps):
    N_tmp = N
    x_config, y_config, z_config = [], [], []
    while N_tmp > 0:
        pi_sum = make_pi_list(Z, N_tmp)
        k = naive_tower_sample(pi_sum)
        if k == 0:
            continue
        x_config += levy_harmonic_path(beta, k)
        y_config += levy_harmonic_path(beta, k)
        z_config += levy_harmonic_path(beta, k)
        N_tmp -= k

import random, math, pylab


def levy_harmonic_path(k):
    x = [random.gauss(0.0, 1.0 / math.sqrt(2.0 * math.tanh(k * beta / 2.0)))]
    if k == 2:
        Ups1 = 2.0 / math.tanh(beta)
        Ups2 = 2.0 * x[0] / math.sinh(beta)
        x.append(random.gauss(Ups2 / Ups1, 1.0 / math.sqrt(Ups1)))
    return x[:]

def pi_x(x, beta):
    sigma = 1.0 / math.sqrt(2.0 * math.tanh(beta / 2.0))
    return math.exp(-x ** 2 / (2.0 * sigma ** 2)) / (math.sqrt(2.0 * math.pi) * sigma)

beta = 2.0
nsteps = 1000000

low = levy_harmonic_path(2)  # tau=0
high = low[:]  # tau=beta
data = []

for step in range(nsteps):
    k = random.choice([0, 1])
    low[k] = levy_harmonic_path(1)[0]
    high[k] = low[k]
    data.append(high[k])

list_x = [0.1 * a for a in range(-30, 31)]
y = [pi_x(a, beta) for a in list_x]

pylab.plot(list_x, y, linewidth=2.0, label='Exact distribution')
pylab.hist(data, density=True, bins=80, label='QMC', alpha=0.5, color='green')
pylab.legend()
pylab.xlabel('$x$', fontsize=14)
pylab.ylabel('$\\pi(x)$', fontsize=14)
pylab.title('2 non-interacting distinguishable 1-d particles', fontsize=14)
pylab.xlim(-3, 3)
pylab.show()

import math, random, pylab, numpy as np

def z(beta):
    return 1.0 / (1.0 - math.exp(- beta))

def pi_two_bosons(x, beta):
    pi_x_1 = math.sqrt(math.tanh(beta / 2.0)) / math.sqrt(math.pi) * math.exp(-x ** 2 * math.tanh(beta / 2.0))
    pi_x_2 = math.sqrt(math.tanh(beta)) / math.sqrt(math.pi) * math.exp(-x ** 2 * math.tanh(beta))
    weight_1 = z(beta) ** 2 / (z(beta) ** 2 + z(2.0 * beta))
    weight_2 = z(2.0 * beta) / (z(beta) ** 2 + z(2.0 * beta))
    pi_x = pi_x_1 * weight_1 + pi_x_2 * weight_2
    return pi_x

def levy_harmonic_path(k, beta):
    x = [random.gauss(0.0, 1.0 / math.sqrt(2.0 * math.tanh(k * beta / 2.0)))]
    if k == 2:
        Ups1 = 2.0 / math.tanh(beta)
        Ups2 = 2.0 * x[0] / math.sinh(beta)
        x.append(random.gauss(Ups2 / Ups1, 1.0 / math.sqrt(Ups1)))
    return x[:]

def rho_harm_1d(x, xp, beta):
    Upsilon_1 = (x + xp) ** 2 / 4.0 * math.tanh(beta / 2.0)
    Upsilon_2 = (x - xp) ** 2 / 4.0 / math.tanh(beta / 2.0)
    return math.exp(- Upsilon_1 - Upsilon_2)

nsteps = 10000
list_beta = np.linspace(0.1, 5.0)
fract_one_cycle_dat, fract_two_cycles_dat = [], []

for beta in list_beta:
    low = levy_harmonic_path(2, beta)
    high = low[:]
    one_cycle_dat = 0.0
    data = []

    for step in range(nsteps):

        if low[0] == high[0]:  # cycle length 1
            k = random.choice([0, 1])
            low[k] = levy_harmonic_path(1, beta)[0]
            high[k] = low[k]
        else:  # cycle length 2
            low[0], low[1] = levy_harmonic_path(2, beta)
            high[1] = low[0]
            high[0] = low[1]
            one_cycle_dat += 1.0 / float(nsteps)
        data += low[:]

        weight_old = rho_harm_1d(low[0], high[0], beta) * rho_harm_1d(low[1], high[1], beta)
        weight_new = rho_harm_1d(low[0], high[1], beta) * rho_harm_1d(low[1], high[0], beta)
        if random.uniform(0.0, 1.0) < weight_new / weight_old:
            high[0], high[1] = high[1], high[0]

    fract_one_cycle_dat.append(one_cycle_dat)
    fract_two_cycles_dat.append(1.0 - one_cycle_dat)

fract_two_cycles = [z(beta) ** 2 / (z(beta) ** 2 + z(2.0 * beta)) for beta in list_beta]
fract_one_cycle = [z(2.0 * beta) / (z(beta) ** 2 + z(2.0 * beta)) for beta in list_beta]

beta = 2.0
list_x = [0.1 * a for a in range(-30, 31)]
y = [pi_two_bosons(a, beta) for a in list_x]
pylab.plot(list_x, y, linewidth=2.0, label='Exact distribution')
pylab.hist(data, density=True, bins=80, label='QMC', alpha=0.5, color='green')
pylab.legend()
pylab.xlabel('$x$', fontsize=14)
pylab.ylabel('$\\pi(x)$', fontsize=14)
pylab.title('2 non-interacting bosonic 1-d particles', fontsize=14)
pylab.xlim(-3, 3)
pylab.savefig('plot_A2_beta%s.png' % beta)
pylab.show()
pylab.clf()
fig = pylab.figure(figsize=(10, 5))

ax = fig.add_subplot(1, 2, 1)
ax.plot(list_beta, fract_one_cycle_dat, linewidth=4, label='QMC')
ax.plot(list_beta, fract_one_cycle, linewidth=2, label='Exact')
ax.legend()
ax.set_xlabel('$\\beta$', fontsize=14)
ax.set_ylabel('$\\pi_2(\\beta)$', fontsize=14)
ax.set_title('Fraction of cycles of length 2', fontsize=14)

ax = fig.add_subplot(1, 2, 2)
ax.plot(list_beta, fract_two_cycles_dat, linewidth=4, label='QMC')
ax.plot(list_beta, fract_two_cycles, linewidth=2, label='Exact')
ax.legend()
ax.set_xlabel('$\\beta$', fontsize=14)
ax.set_ylabel('$\\pi_1(\\beta)$', fontsize=14)
ax.set_title('Fraction of cycles of length 1', fontsize=14)

pylab.show()
pylab.clf()

import math, random, pylab

def prob_r_distinguishable(r, beta):
    sigma = math.sqrt(2.0) / math.sqrt(2.0 * math.tanh(beta / 2.0))
    prob = (math.sqrt(2.0 / math.pi) / sigma) * math.exp(- r ** 2 / 2.0 / sigma ** 2)
    return prob

def levy_harmonic_path(k):
    x = [random.gauss(0.0, 1.0 / math.sqrt(2.0 * math.tanh(k * beta / 2.0)))]
    if k == 2:
        Ups1 = 2.0 / math.tanh(beta)
        Ups2 = 2.0 * x[0] / math.sinh(beta)
        x.append(random.gauss(Ups2 / Ups1, 1.0 / math.sqrt(Ups1)))
    return x[:]

def rho_harm_1d(x, xp, beta):
    Upsilon_1 = (x + xp) ** 2 / 4.0 * math.tanh(beta / 2.0)
    Upsilon_2 = (x - xp) ** 2 / 4.0 / math.tanh(beta / 2.0)
    return math.exp(- Upsilon_1 - Upsilon_2)

beta = 0.1
nsteps = 1000000
low_1, low_2 = levy_harmonic_path(2)
x = {low_1: low_1, low_2: low_2}
data_corr = []

for step in range(nsteps):
    # move 1
    a = random.choice(list(x.keys()))
    if a == x[a]:
        dummy = x.pop(a)
        a_new = levy_harmonic_path(1)[0]
        x[a_new] = a_new
    else:
        a_new, b_new = levy_harmonic_path(2)
        x = {a_new: b_new, b_new: a_new}
    keys = list(x.keys())
    r = abs(keys[1] - keys[0])
    data_corr.append(r)
    # move 2
    (low1, high1), (low2, high2) = list(x.items())
    weight_old = rho_harm_1d(low1, high1, beta) * rho_harm_1d(low2, high2, beta)
    weight_new = rho_harm_1d(low1, high2, beta) * rho_harm_1d(low2, high1, beta)
    if random.uniform(0.0, 1.0) < weight_new / weight_old:
        x = {low1: high2, low2: high1}


list_x = [0.1 * a for a in range(0, 100)]
y = [prob_r_distinguishable(a, beta) for a in list_x]
pylab.plot(list_x, y, linewidth=2.0, label='Exact distinguishable distribution')
pylab.hist(data_corr, density=True, bins=120, label='Indistinguishable QMC', alpha=0.5, color='green')
pylab.legend()
pylab.xlabel('$r$', fontsize=14)
pylab.ylabel('$\\pi_{corr}(r)$', fontsize=14)
pylab.title('Correlation function of non-interacting 1-d bosons', fontsize=14)
pylab.xlim(0, 10)
pylab.show()
pylab.clf()

"""
3-dimensional bosons
Isotropic trap"""

import random, math, numpy, sys, os
import matplotlib.pyplot as plt
import pylab
from mpl_toolkits.mplot3d import Axes3D

def harmonic_ground_state(x):
    return math.exp(-x ** 2) / math.sqrt(math.pi)

def levy_harmonic_path_3d_anisotropic(k):
    return levy_harmonic_path_3d(k)

def levy_harmonic_path_3d(k):
    x0 = tuple([random.gauss(0.0, 1.0 / math.sqrt(2.0 * math.tanh(k * beta / 2.0))) for _ in range(3)])
    x = [x0]
    for j in range(1, k):
        Upsilon_1 = 1.0 / math.tanh(beta) + 1.0 / math.tanh((k - j) * beta)
        Upsilon_2 = [x[j - 1][d] / math.sinh(beta) + x[0][d] / math.sinh((k - j) * beta) for d in range(3)]
        x_mean = [Upsilon_2[d] / Upsilon_1 for d in range(3)]
        sigma = 1.0 / math.sqrt(Upsilon_1)
        dummy = [random.gauss(x_mean[d], sigma) for d in range(3)]
        x.append(tuple(dummy))
    return x

def rho_harm_3d(x, xp):
    Upsilon_1 = sum((x[d] + xp[d]) ** 2 / 4.0 * math.tanh(beta / 2.0) for d in range(3))
    Upsilon_2 = sum((x[d] - xp[d]) ** 2 / 4.0 / math.tanh(beta / 2.0) for d in range(3))
    return math.exp(- Upsilon_1 - Upsilon_2)

N = 512
T_star = 0.8
list_T = numpy.linspace(0.8, 0.1, 5)
beta = 1.0 / (T_star * N ** (1.0 / 3.0))
cycle_min = 10
nsteps = 50000
data_x, data_y, data_x_l, data_y_l = [], [], [], []

for T_star in list_T:
    filename = 'data_boson_configuration_N%i_T%.1f.txt' % (N, T_star)
    positions = {}

    if os.path.isfile(filename):
        with open(filename, 'r') as f:
            for line in f:
                a = line.split()
                positions[tuple(map(float, a[:3]))] = tuple(map(float, a[3:]))
        if len(positions) != N:
            sys.exit('ERROR in the input file.')
        print('Starting from file', filename)
    else:
        for _ in range(N):
            a = levy_harmonic_path_3d_anisotropic(1)
            positions[a[0]] = a[0]
        print('Starting from a new configuration')

    for step in range(nsteps):
        boson_a = random.choice(list(positions))
        perm_cycle = []
        while True:
            perm_cycle.append(boson_a)
            boson_b = positions.pop(boson_a)
            if boson_b == perm_cycle[0]:
                break
            boson_a = boson_b
        k = len(perm_cycle)
        data_x.append(boson_a[0])
        data_y.append(boson_a[1])
        if k > cycle_min:
            data_x_l.append(boson_a[0])
            data_y_l.append(boson_a[1])
        perm_cycle = levy_harmonic_path_3d(k)
        positions[perm_cycle[-1]] = perm_cycle[0]
        for i in range(len(perm_cycle) - 1):
            positions[perm_cycle[i]] = perm_cycle[i + 1]

        a_1 = random.choice(list(positions))
        b_1 = positions.pop(a_1)
        a_2 = random.choice(list(positions))
        b_2 = positions.pop(a_2)
        weight_new = rho_harm_3d(a_1, b_2) * rho_harm_3d(a_2, b_1)
        weight_old = rho_harm_3d(a_1, b_1) * rho_harm_3d(a_2, b_2)
        if random.uniform(0.0, 1.0) < weight_new / weight_old:
            positions[a_1] = b_2
            positions[a_2] = b_1
        else:
            positions[a_1] = b_1
            positions[a_2] = b_2

    with open(filename, 'w') as f:
        for a, b in positions.items():
            f.write(f"{a[0]} {a[1]} {a[2]} {b[0]} {b[1]} {b[2]}\n")

    fig = pylab.figure()
    ax = fig.add_subplot(111, projection='3d')
    ax.set_box_aspect([1,1,1])
    n_colors = 10
    list_colors = pylab.cm.rainbow(numpy.linspace(0, 1, n_colors))[::-1]
    dict_colors = {}
    i_color = 0
    positions_copy = positions.copy()
    while positions_copy:
        x, y, z = [], [], []
        starting_boson = list(positions_copy.keys())[0]
        boson_old = starting_boson
        while True:
            x.append(boson_old[0])
            y.append(boson_old[1])
            z.append(boson_old[2])
            boson_new = positions_copy.pop(boson_old)
            if boson_new == starting_boson:
                break
            boson_old = boson_new
        len_cycle = len(x)
        if len_cycle > 2:
            x.append(x[0])
            y.append(y[0])
            z.append(z[0])
        color = dict_colors.get(len_cycle, list_colors[i_color])
        dict_colors[len_cycle] = color
        i_color = (i_color + 1) % n_colors
        ax.plot(x, y, z, '+-', c=color, label=f'k={len_cycle}', lw=0.75)
    pylab.title(f'{N} bosons at T* = {T_star:.1f}')
    pylab.legend()
    ax.set_xlabel('$x$', fontsize=16)
    ax.set_ylabel('$y$', fontsize=16)
    ax.set_zlabel('$z$', fontsize=16)
    xmax = 6.0
    ax.set_xlim([-xmax, xmax])
    ax.set_ylim([-xmax, xmax])
    ax.set_zlim([-xmax, xmax])
    pylab.savefig(f'plot_boson_configuration_N{N}_T{T_star:.1f}.png')
    pylab.show()
    pylab.clf()


list_x = [0.1 * a for a in range(-50, 51)]
y = [harmonic_ground_state(a) for a in list_x]
pylab.plot(list_x, y, linewidth=2.0, label='Ground state')
pylab.hist(data_x, density=True, bins=120, alpha=0.5, label='All bosons')
pylab.hist(data_x_l, density=True, bins=120, alpha=0.5, label='Bosons in longer cycle')
pylab.xlim(-3.0, 3.0)
pylab.xlabel('$x$', fontsize=14)
pylab.ylabel('$\pi(x)$', fontsize=14)
pylab.title(f'3-d non-interacting bosons $x$ distribution $N={N}$, $T={T_star:.1f}$')
pylab.legend()
pylab.savefig(f'position_distribution_N{N}_T{T_star:.1f}.png')
pylab.show()
pylab.clf()

plt.hist2d(data_x_l, data_y_l, bins=40, density=True)
plt.xlabel('$x$')
plt.ylabel('$y$')
plt.title('The distribution of the $x$ and $y$ positions')
plt.colorbar()
plt.xlim(-3.0, 3.0)
plt.ylim(-3.0, 3.0)
plt.show()

"""Anisotropic trap"""

import os
import sys
import math
import random
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

def levy_harmonic_path_3d_anisotropic(k, omega, beta):
    """Generates a Levy flight for a 3D anisotropic harmonic oscillator."""
    sigma = [1.0 / math.sqrt(2.0 * omega[d] * math.tanh(0.5 * k * beta * omega[d])) for d in range(3)]
    xk = tuple(random.gauss(0.0, sigma[d]) for d in range(3))
    x = [xk]

    for j in range(1, k):
        Upsilon_1 = [1.0 / math.tanh(beta * omega[d]) + 1.0 / math.tanh((k - j) * beta * omega[d]) for d in range(3)]
        Upsilon_2 = [x[j - 1][d] / math.sinh(beta * omega[d]) + xk[d] / math.sinh((k - j) * beta * omega[d]) for d in range(3)]
        x_mean = [Upsilon_2[d] / Upsilon_1[d] for d in range(3)]
        sigma = [1.0 / math.sqrt(Upsilon_1[d] * omega[d]) for d in range(3)]
        x.append(tuple(random.gauss(x_mean[d], sigma[d]) for d in range(3)))

    return x

def rho_harm_3d_anisotropic(x, xp, beta, omega):
    """Computes the free-particle density matrix in a 3D anisotropic harmonic oscillator."""
    Upsilon_1 = sum(omega[d] * (x[d] + xp[d]) ** 2 / 4.0 * math.tanh(beta * omega[d] / 2.0) for d in range(3))
    Upsilon_2 = sum(omega[d] * (x[d] - xp[d]) ** 2 / 4.0 / math.tanh(beta * omega[d] / 2.0) for d in range(3))
    return math.exp(-Upsilon_1 - Upsilon_2)

omegas = np.array([[4.0, 4.0, 1.0], [1.0, 5.0, 1.0]])

for i in range(omegas.shape[0]):
    N = 512
    nsteps = 100000
    omega = omegas[i, :]
    omega_harm = np.prod(omega) ** (1.0 / 3.0)

    T_star = 0.5
    T = T_star * omega_harm * N ** (1.0 / 3.0)
    beta = 1.0 / T

    print("omega:", omega)

    if i == 0:
        filename = f"data_boson_configuration_anisotropic_N{N}_T{T_star:.1f}_cigar.txt"
    else:
        filename = f"data_boson_configuration_anisotropic_N{N}_T{T_star:.1f}_pancake.txt"

    positions = {}
    if os.path.isfile(filename):
        with open(filename, "r") as f:
            for line in f:
                a = list(map(float, line.split()))
                positions[tuple(a[0:3])] = tuple(a[3:6])
        if len(positions) != N:
            sys.exit("ERROR in the input file.")
        print("Starting from file", filename)
    else:
        for _ in range(N):
            a = levy_harmonic_path_3d_anisotropic(1, omega, beta)
            positions[a[0]] = a[0]
        print("Starting from a new configuration")

        # The following for loop was not indented properly
        for step in range(nsteps):
            boson_a = random.choice(list(positions.keys()))
            perm_cycle = []

            while True:
                perm_cycle.append(boson_a)
                boson_b = positions.pop(boson_a)
                if boson_b == perm_cycle[0]:
                    break
                else:
                    boson_a = boson_b

            k = len(perm_cycle)
            new_cycle = levy_harmonic_path_3d_anisotropic(k, omega, beta)
            positions[new_cycle[-1]] = new_cycle[0]
            for j in range(k - 1):
                positions[new_cycle[j]] = new_cycle[j + 1]

            a1 = random.choice(list(positions.keys()))
            b1 = positions.pop(a1)
            a2 = random.choice(list(positions.keys()))
            b2 = positions.pop(a2)

            weight_new = rho_harm_3d_anisotropic(a1, b2, beta, omega) * rho_harm_3d_anisotropic(a2, b1, beta, omega)
            weight_old = rho_harm_3d_anisotropic(a1, b1, beta, omega) * rho_harm_3d_anisotropic(a2, b2, beta, omega)

            if random.uniform(0.0, 1.0) < weight_new / weight_old:
                positions[a1], positions[a2] = b2, b1
            else:
                positions[a1], positions[a2] = b1, b2

    with open(filename, "w") as f:
        for a in positions:
            b = positions[a]
            f.write(f"{a[0]} {a[1]} {a[2]} {b[0]} {b[1]} {b[2]}\n")

    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    ax.set_aspect('auto')
    list_colors = plt.cm.rainbow(np.linspace(0, 1, 10))[::-1]
    dict_colors = {}
    i_color = 0

    positions_copy = positions.copy()
    while positions_copy:
        x, y, z = [], [], []
        start = list(positions_copy.keys())[0]
        current = start

        while True:
            x.append(current[0])
            y.append(current[1])
            z.append(current[2])
            next_boson = positions_copy.pop(current)
            if next_boson == start:
                break
            current = next_boson

        k = len(x)
        if k > 2:
            x.append(x[0])
            y.append(y[0])
            z.append(z[0])

        if k in dict_colors:
            color = dict_colors[k]
        else:
            color = list_colors[i_color]
            dict_colors[k] = color
            i_color = (i_color + 1) % 10

        ax.plot(x, y, z, '+-', c=color, lw=0.75, label=f'k={k}' if k not in dict_colors else "")

    ax.set_xlabel('$x$', fontsize=16)
    ax.set_ylabel('$y$', fontsize=16)
    ax.set_zlabel('$z$', fontsize=16)
    ax.set_xlim([-8, 8])
    ax.set_ylim([-8, 8])
    ax.set_zlim([-8, 8])

    plt.title(f"{N} bosons at T* = {T_star} " + ("cigar potential" if i == 0 else "pancake potential"))
    plt.legend()
    plt.tight_layout()
    plt.show()

